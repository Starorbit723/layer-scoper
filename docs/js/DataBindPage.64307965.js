"use strict";(self["webpackChunklayerscoper"]=self["webpackChunklayerscoper"]||[]).push([[343],{3850:function(t,n,a){a.r(n),a.d(n,{default:function(){return u}});var s=function(){var t=this,n=t._self._c;return n("div",{staticClass:"databindpage-content ls-content-wrapper"},[n("div",{staticClass:"ls-title-lv1"},[t._v("数据绑定")]),t._m(0),t._m(1),n("div",{staticClass:"ls-title-lv2 ls-top-30"},[t._v("HTML")]),n("CodeView",{attrs:{codeText:t.dataHtmlCode,codeType:"html"}}),n("div",{staticClass:"ls-title-lv2 ls-top-30"},[t._v("绑定数据到节点")]),n("CodeView",{attrs:{codeText:t.dataJs,codeType:"javascript"}}),n("div",{staticClass:"ls-text ls-top-30"},[t._v(" DOM节点绑定数据之后，数据去了那里？怎么回传给开发者？开发者还能知道哪些信息？详见"),n("router-link",{attrs:{to:{name:"callback"}}},[n("span",{staticClass:"ls-textfocus"},[t._v("回调")])]),t._v("。 ")],1)],1)},c=[function(){var t=this,n=t._self._c;return n("div",{staticClass:"ls-text ls-top-40"},[t._v(" Web应用技术发展至今，"),n("span",{staticClass:"ls-textfocus"},[t._v("数据绑定")]),t._v("以及数据驱动才是渲染的核心。大多数的应用场景下数据会以"),n("span",{staticClass:"ls-textfocus"},[t._v("同步")]),t._v("或"),n("span",{staticClass:"ls-textfocus"},[t._v("异步")]),t._v("方式来绑定到DOM节点上，当某个节点的"),n("span",{staticClass:"ls-textfocus"},[t._v("事件绑定(EventBind)")]),t._v("被触发时，开发者可以根据绑定到该节点的数据来进行后续的操作。 ")])},function(){var t=this,n=t._self._c;return n("div",{staticClass:"ls-block ls-top-20"},[n("div",{staticClass:"ls-text"},[n("span",{staticClass:"ls-textfocus"},[t._v("Attribute")]),t._v(" 只能接收字符串，因此binddata只能传字符串类型的数据，即便传了"),n("span",{staticClass:"ls-textfocus"},[t._v("Number")]),t._v("，最终也会被转换成"),n("span",{staticClass:"ls-textfocus"},[t._v("String")]),t._v("。为了保证数据的类型不会在绑定过程中改变，建议使用Object包裹，并转化成JSON来绑定。 ")])])}],e=a(7795),l=a(5741),i={name:"DataBindPage",components:{CodeView:e.A},data(){return{dataHtml:l.C,dataJs:l.w}},computed:{dataHtmlCode(){return this.dataHtml},dataJsCode(){return this.dataJs}}},o=i,d=a(1656),r=(0,d.A)(o,s,c,!1,null,null,null),u=r.exports},5741:function(t,n,a){a.d(n,{C:function(){return s},w:function(){return c}});const s='\x3c!--\n  Attribute只能接收字符串，因此binddata只能传字符串类型，为了保证数据的类型不会在绑定过程中改变，建议使用Object包裹\n--\x3e\n<div id="content">\n  <div class="list scoped" scoped="1">\n    <div class="list-item incontroll" binddata={JSON.stringify(dataObject1)}>落焦点-item-1</div>\n    <div class="list-item incontroll" binddata={JSON.stringify(dataObject2)}>落焦点-item-2</div>\n  </div>\n  <div class="list2 scoped" scoped="2">\n    <div\n      v-for="item in dataList"\n      :key="item.id"\n      class="list-item incontroll"\n      binddata={JSON.stringify(item)}>{{item.name}}</div>\n  </div>\n</div>\n',c="import LayerScoper from 'layer-scoper';\n\nconst layerScoperCase = new LayerScoper();\n...\ndata() {\n  return {\n    dataObject1: {\n      id: 1,\n      age: 23,\n    },\n    dataObject2: {\n      id: 2,\n      sex: \"male\"\n    },\n    dataList: [{\n      id: 4,\n      name: \"Jack\"\n    },{\n      id: 5,\n      name: \"Tom\"\n    },{\n      id: 6,\n      name: \"Michael\"\n    }]\n  }\n}\n\n// Api: initController() 用于初始化，只需在DOM加载完成后调用一次即可\n...\nmounted() {\n  layerScoperCase.initController({\n    id: 'content',\n    defaultPoint: { y: 1, x: 1 },\n    callBackFn: {\n      cbFocusUp: this.onFocusUpCallback,\n      cbFocusDown: this.onFocusDownCallback,\n      cbFocusLeft: this.onFocusLeftCallback,\n      cbFocusRight: this.onFocusRightCallback,\n      cbBackSpace: this.onBackSpaceClickCallback,\n      cbFocusChange: this.onFocusChangeCallback,\n    }\n  });\n}\n...\n\n// 回调预留方法，开发者自定义，并传入初始化\n...\nmethod: {\n  // 默认回调绑定的方法\n  onFocusUpCallback(cbData) {\n    console.log('焦点上移', cbData.);\n  },\n  onFocusDownCallback(cbData) {\n    console.log('焦点下移', cbData);\n  },\n  onFocusLeftCallback(cbData) {\n    console.log('焦点左移', cbData);\n  },\n  onFocusRightCallback(cbData) {\n    console.log('焦点右移', cbData);\n  },\n  onBackSpaceClickCallback(cbData) {\n    console.log('按了后退/返回键', cbData);\n  },\n  onFocusChangeCallback(cbData) {\n    console.log('焦点移动/改变', cbData);\n  },\n}\n...\n\n"}}]);
//# sourceMappingURL=DataBindPage.64307965.js.map