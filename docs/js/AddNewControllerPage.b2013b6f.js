"use strict";(self["webpackChunklayerscoper"]=self["webpackChunklayerscoper"]||[]).push([[11],{3714:function(t,n,i){i.d(n,{A:function(){return d}});var e=function(){var t=this,n=t._self._c;return n("div",{staticClass:"tableview-content"},[n("div",{staticClass:"thead ellipsis clearfix",style:{display:t.tableData.tableConfig.suitable?"flex":"block"}},[t.tableData.tableConfig.suitable?t._e():n("div",t._l(t.tableData.thead,(function(i,e){return n("div",{key:i.th,staticClass:"th-item-no-suitable",style:{width:t.tableData.tableConfig.width[e]+"%"}},[t._v(t._s(i.th))])})),0),t.tableData.tableConfig.suitable?n("div",t._l(t.tableData.thead,(function(i){return n("div",{key:i.th,staticClass:"th-item-suitable"},[t._v(t._s(i.th))])})),0):t._e()]),n("div",{staticClass:"tbody"},t._l(t.tableData.tbody,(function(i,e){return n("div",{key:e,staticClass:"row clearfix"},[t.tableData.tableConfig.suitable?t._e():n("div",{staticClass:"row-inner"},t._l(i,(function(i,e){return n("div",{key:e,class:{"col-item-no-suitable":!0,focus:i.focus},style:{width:t.tableData.tableConfig.width[e]+"%"}},[n("div",{staticClass:"inner",style:{textAlign:t.tableData.tableConfig.align[e]?t.tableData.tableConfig.align[e]:"center"}},[t._v(t._s(i.txt))])])})),0),t.tableData.tableConfig.suitable?n("div",{staticClass:"row-inner"},t._l(i,(function(i,e){return n("div",{key:e,class:{"col-item-suitable":!0,focus:i.focus}},[n("div",{staticClass:"inner"},[t._v(t._s(i.txt))])])})),0):t._e()])})),0)])},l=[],s={name:"TableView",props:{a:{type:Number},tableData:{type:Object}}},o=s,a=i(1656),c=(0,a.A)(o,e,l,!1,null,"6d39cfb6",null),d=c.exports},5156:function(t,n,i){i.r(n),i.d(n,{default:function(){return u}});var e=function(){var t=this,n=t._self._c;return n("div",{staticClass:"ls-content-wrapper"},[n("div",{staticClass:"ls-title-lv1"},[t._v("添加新的图层")]),n("div",{staticClass:"ls-title-lv2 ls-top-30"},[t._v("addNewController()")]),t._m(0),t._m(1),n("CodeView",{attrs:{codeText:t.addNewControllerHtmlCode,codeType:"html"}}),n("CodeView",{attrs:{codeText:t.addNewControllerJsCode,codeType:"javascript"}}),n("div",{staticClass:"ls-block ls-top-30"},[n("ul",{staticClass:"ls-list-content"},[t._m(2),t._m(3),n("li",{staticClass:"ls-top-20"},[t._v("Q：新的图层展示出来，此时的焦点还停留在之前的图层里，怎么办？"),n("br"),t._v(" A：新的图层被展示出来了，Layer Scoper遵循了"),n("span",{staticClass:"ls-textfocus"},[t._v("“有且仅有一个落焦点(Focus)”")]),t._v("的原则，可以通过"),n("span",{staticClass:"ls-textfocus"},[t._v("wakeUp(唤醒)")]),t._v("方法来将焦点切换到"),n("br"),t._v("      开发者需要交互的新图层内，详见"),n("router-link",{attrs:{to:{name:"wakeup"}}},[n("span",{staticClass:"ls-textfocus"},[t._v("wakeUp 唤醒")])]),t._v("。")],1)])]),n("div",{staticClass:"ls-title-lv2 ls-top-30"},[t._v("参数文档")]),n("TableView",{staticClass:"ls-top-30",attrs:{tableData:t.initControllerData}})],1)},l=[function(){var t=this,n=t._self._c;return n("div",{staticClass:"ls-text ls-top-30"},[t._v(" 用户初始化Layer Scoper实例，同一个页面的生命周期内只需要初始化一次。后续如果希望添加一个新的"),n("span",{staticClass:"ls-textfocus"},[t._v("图层(Layer)")]),t._v("可以随时通过调用"),n("span",{staticClass:"ls-textfocus"},[t._v("addNewController()")]),t._v("方法同步添加新图层，由于每个图层的能力都是平行相同的，也是各自独立的。所以方法出传入的参数其实和"),n("span",{staticClass:"ls-textfocus"},[t._v("初始化 initController()")]),t._v("的参数是完全相同的。"),n("br"),n("br"),t._v(" 要注意的是："),n("span",{staticClass:"ls-textfocus"},[t._v("添加新图层 addNewController()")]),t._v("的方法必须在初始化"),n("span",{staticClass:"ls-textfocus"},[t._v("初始化 initController()")]),t._v("完成之后才能调用，否则不会生效。"),n("br"),n("br"),t._v(" 如下示例：在原有的页面中，添加一个对话弹框图层，与页面图层彼此独立。 ")])},function(){var t=this,n=t._self._c;return n("div",{staticClass:"ls-image ls-image50 ls-top-30"},[n("img",{attrs:{src:i(9524)}})])},function(){var t=this,n=t._self._c;return n("li",[t._v("Q：添加完了新的图层，但是并没有立刻展示到页面上啊？"),n("br"),t._v(" A：图层添加是指在DOM维度上，该图层可被Layer Scoper控制。但是具体这个图层需要什么时候展示隐藏，应该由开发者自行控制。"),n("br"),t._v("      也就是说，即便DOM是暂时不可见的（display: none），也可以随时被添加于Layer Scoper实例当中。")])},function(){var t=this,n=t._self._c;return n("li",{staticClass:"ls-top-20"},[t._v("Q：添加完了新的图层，原有图层上的设置与配置会被修改吗？"),n("br"),t._v(" A：每个图层都是各自平行且独立，一个页面只需要一个Layer Scoper实例，但是一个实例下的图层可以有无数个，互相不干扰。")])}],s=i(792),o=i(3714),a=i(1192),c=i(8233),d={name:"InitControllerPage",components:{CodeView:s.A,TableView:o.A},data(){return{initControllerData:c,addNewControllerHtml:a.Hw,addNewControllerJs:a.FQ}},computed:{addNewControllerHtmlCode(){return this.addNewControllerHtml},addNewControllerJsCode(){return this.addNewControllerJs}}},r=d,v=i(1656),x=(0,v.A)(r,e,l,!1,null,null,null),u=x.exports},1192:function(t,n,i){i.d(n,{Bi:function(){return r},FQ:function(){return s},Hw:function(){return l},KS:function(){return e},ND:function(){return c},Q$:function(){return u},TF:function(){return o},TW:function(){return a},j7:function(){return d},lD:function(){return v},o4:function(){return x}});const e="import { ScopeController } from 'utils/scopeController';\n\nconst controllerCase = new ScopeController();\n\n// Api: initController() 用于初始化，只需在DOM加载完成后调用一次即可\n...\nmounted() {\n  controllerCase.initController({\n    id: 'content',\n    defaultPoint: { y: 1, x: 1 },\n    needScroll: true,\n    scrollDirection: 'vertical', // horizontal vertical\n    scrollBarConfig: {\n      showScrollBar: true,\n      trackWidth: '8px',\n      trackBackground: 'rgba(255,255,255,0)',\n      trackBorderRadius: '0',\n      thumbColor: 'rgb(25, 170, 6)',\n      thumbBorderWidth: '2px',\n      thumbBorderColor: 'rgb(25, 170, 6)',\n      thumbBorderRadius: '4px',\n      thumbHoverColor: 'rgb(25, 170, 6)',\n    },\n    callBackFn: {\n      cbFocusUp: this.onFocusUpCallback,\n      cbFocusDown: this.onFocusDownCallback,\n      cbFocusLeft: this.onFocusLeftCallback,\n      cbFocusRight: this.onFocusRightCallback,\n      cbBackSpace: this.onBackSpaceClickCallback,\n      cbFocusChange: this.onFocusChangeCallback,\n    },\n    selfDefinedCallBackFn: {\n      clickMe: this.clickMeFn,\n      selfGoLeft: this.selfGoLeftFn,\n      selfGoRight: this.selfGoRightFn,\n      selfGoUp: this.selfGoUpFn,\n      selfGoDown: this.selfGoDownFn,\n    }\n  });\n}\n...\n\n// 回调预留方法，开发者自定义，并传入初始化\n...\nmethod: {\n  // 默认回调绑定的方法\n  onFocusUpCallback(cbData) {\n    console.log('焦点上移', cbData);\n  },\n  onFocusDownCallback(cbData) {\n    console.log('焦点下移', cbData);\n  },\n  onFocusLeftCallback(cbData) {\n    console.log('焦点左移', cbData);\n  },\n  onFocusRightCallback(cbData) {\n    console.log('焦点右移', cbData);\n  },\n  onBackSpaceClickCallback(cbData) {\n    console.log('按了后退/返回键', cbData);\n  },\n  onFocusChangeCallback(cbData) {\n    console.log('焦点移动/改变', cbData);\n  },\n  // 自定义回调绑定的方法\n  clickMeFn(cbData) {\n    console.log('在这个Item点击了确认', cbData);\n  },\n  selfGoLeftFn(cbData) {\n    console.log('在这个Item点击了左键', cbData);\n  },\n  selfGoRightFn(cbData) {\n    console.log('在这个Item点击了右键', cbData);\n  },\n  selfGoUpFn(cbData) {\n    console.log('在这个Item点击了上键', cbData);\n  },\n  selfGoDownFn(cbData) {\n    console.log('在这个Item点击了下键', cbData);\n  },\n}\n...\n",l='<div id="App">\n\n  \x3c!-- 主内容图层 --\x3e\n  <div id="content">\n    <div class="list scoped" scoped="1">\n      <div class="list-item incontroll">落焦点-item-1</div>\n      <div class="list-item incontroll">落焦点-item-2</div>\n      <div class="list-item incontroll">落焦点-item-3</div>\n    </div>\n    <div class="list2 scoped" scoped="2">\n      <div class="list2-item incontroll">落焦点-item-1</div>\n      <div class="list2-item">非落焦点-item-2</div>\n      <div class="list2-item">非落焦点-item-3</div>\n      <div class="list2-item incontroll">落焦点-item-4</div>\n    </div>\n    <div class="list3 scoped" scoped="2.1">\n      <div class="list3-item incontroll">落焦点-item-1</div>\n      <div class="list3-item incontroll">落焦点-item-2</div>\n      <div class="list3-item">非落焦点-item-3</div>\n    </div>\n  </div>\n\n  \x3c!-- 对话弹框图层 --\x3e\n  <div id="dialog-content" v-show="showDialog">\n    <div className=\'dialog-bg\'></div>\n    <div className=\'dialog-innerwrapper\'>\n        <div className=\'btn-zone scoped\' scoped={1}>\n          <div className=\'diabtn incontroll\' clickfocus="onCloseDialog">返回</div>\n          <div className=\'diabtn incontroll\' clickfocus="onEnsureDialog">确认</div>\n        </div>\n    </div>\n  </div>\n\n</div>\n',s="...\nmounted() {\n  controllerCase.addNewController({\n    id: 'dialog-content',\n    defaultPoint: { y: 1, x: 2 },\n    needScroll: false,\n    selfDefinedCallBackFn: {\n      onCloseDialog: this.onCloseDialogFn,\n      onEnsureDialog: this.onEnsureDialogFn,\n    }\n  });\n  // 展示/隐藏还是要开发者自己控制的\n  this.showDialog = true;\n}\n...\ndata() {\n  return {\n    showDialog: false\n  }\n}\n...\n// 回调预留方法，开发者自定义，并传入初始化\n...\nmethod: {\n  // 自定义回调绑定的方法\n  onEnsureDialogFn(cbData) {\n    console.log('在对话框，点击了确认', cbData);\n  },\n  onCloseDialogFn(cbData) {\n    console.log('在对话框，点击了关闭', cbData);\n  }\n}\n...\n",o='<div id="App">\n\n  \x3c!-- 主内容图层 --\x3e\n  <div id="content">\n    <div class="list scoped" scoped="1">\n      <div class="list-item incontroll">落焦点-item-1</div>\n      <div class="list-item incontroll">落焦点-item-2</div>\n    </div>\n    <div class="list2 scoped" scoped="2">\n      <div class="list2-item incontroll">落焦点-item-1</div>\n      <div class="list2-item incontroll">落焦点-item-2</div>\n      <div class="list2-item incontroll" clickfocus="openAside">落焦点-item-3</div>\n      <div class="list2-item incontroll">落焦点-item-4</div>\n    </div>\n    <div class="list3 scoped" scoped="2.1">\n      <div class="list3-item incontroll">落焦点-item-1</div>\n      <div class="list3-item incontroll">落焦点-item-2</div>\n      ...\n      <div class="list3-item incontroll"">落焦点-item-12</div>\n    </div>\n  </div>\n\n  \x3c!-- 侧浮层图层 --\x3e\n  <div id="aside-content" v-show="showAside">\n    <div className=\'aside-bg\'></div>\n    <div className=\'aside-innerwrapper\'>\n      <div class="list scoped" scoped="1">\n        <div class="list-item incontroll">落焦点-item-1</div>\n        <div class="list-item incontroll">落焦点-item-2</div>\n      </div>\n      <div class="list2 scoped" scoped="2">\n        <div class="list-item incontroll">落焦点-item2-1</div>\n        <div class="list-item incontroll" clickfocus="closeAside">落焦点-item2-2</div>\n        <div class="list-item incontroll">落焦点-item2-3</div>\n        <div class="list-item incontroll">落焦点-item2-4</div>\n      </div>\n    </div>\n  </div>\n\n</div>\n',a="...\nmounted() {\n  // 初始化\n  controllerCase.initController({\n    id: 'content',\n    defaultPoint: { y: 1, x: 1 },\n    needScroll: false,\n    selfDefinedCallBackFn: {\n      openAside: this.openAsideFn,\n    }\n  });\n\n  // 添加新的图层\n  controllerCase.addNewController({\n    id: 'aside-content',\n    defaultPoint: { y: 1, x: 1 },\n    needScroll: false,\n    selfDefinedCallBackFn: {\n      closeAside: closeAsideFn,\n    }\n  });\n  \n}\n...\ndata() {\n  return {\n    showAside: false\n  }\n}\n...\n// 回调预留方法，开发者自定义，并传入初始化\n...\nmethod: {\n  // 点击打开侧浮层\n  openAsideFn(cbData) {\n    // 展示/隐藏还是要开发者自己控制的\n    this.showAside = true;\n    // 唤醒该图层\n    controllerCase.wakeUp({\n      id: 'aside-content',\n      targetY: 2,\n      targetX: 2\n    });\n  },\n  // 点击关闭侧浮层\n  closeAsideFn(cbData) {\n    // 展示/隐藏还是要开发者自己控制的\n    this.showAside = false;\n    // 唤醒之前的页面主体图层\n    controllerCase.wakeUp({\n      id: 'content'\n    });\n  }\n}\n...\n",c='<div id="App">\n\n  \x3c!-- 主内容图层 --\x3e\n  <div id="content">\n    <div class="list scoped" scoped="1">\n      <div class="list-item incontroll">落焦点-item-1</div>\n      <div class="list-item incontroll">落焦点-item-2</div>\n    </div>\n    <div class="list2 scoped" scoped="2">\n      <div class="list2-item incontroll">落焦点-item-1</div>\n      <div class="list2-item incontroll">落焦点-item-2</div>\n      <div class="list2-item incontroll" clickfocus="handleChangeFocus">落焦点-item-3</div>\n      <div class="list2-item incontroll">落焦点-item-4</div>\n    </div>\n    <div class="list3 scoped" scoped="3">\n      <div class="list3-item incontroll">落焦点-item-1</div>\n      <div class="list3-item incontroll">落焦点-item-2</div>\n      ...\n      <div class="list3-item incontroll">落焦点-item-7</div>\n      <div class="list3-item incontroll">落焦点-item-8</div>\n      ...\n      <div class="list3-item incontroll"">落焦点-item-12</div>\n    </div>\n  </div>\n\n</div>\n',d="...\nmounted() {\n  // 初始化\n  controllerCase.initController({\n    id: 'content',\n    defaultPoint: { y: 2, x: 3 },\n    needScroll: false,\n    selfDefinedCallBackFn: {\n      handleChangeFocus: this.handleChangeFocusFn,\n    }\n  });\n}\n...\nmethod: {\n  // 当【落焦点-item-3】点击确认时，手动移动焦点到指定位置\n  handleChangeFocusFn(cbData) {\n    controllerCase.goToFocus({\n      targetY: 3,\n      targetX: 8,\n    });\n  }\n}\n...\n",r='<div id="App">\n\n  \x3c!-- 主内容图层 --\x3e\n  <div id="content">\n    <div class="list scoped" scoped="1">\n      <div class="list-item incontroll">落焦点-item-1</div>\n      <div class="list-item incontroll">落焦点-item-2</div>\n    </div>\n    <div class="list2 scoped" scoped="2">\n      <div class="list2-item incontroll">落焦点-item-1</div>\n      <div class="list2-item incontroll">落焦点-item-2</div>\n      <div class="list2-item incontroll focus">落焦点-item-3</div>\n      <div class="list2-item incontroll">落焦点-item-4</div>\n    </div>\n    <div class="list3 scoped" scoped="3">\n      <div class="list3-item incontroll">落焦点-item-1</div>\n      <div class="list3-item incontroll">落焦点-item-2</div>\n      ...\n      <div class="list3-item incontroll"">落焦点-item-12</div>\n    </div>\n  </div>\n\n</div>\n',v="...\nmounted() {\n  // 初始化\n  controllerCase.initController({\n    id: 'content',\n    defaultPoint: { y: 2, x: 3 },\n    needScroll: false\n  });\n  this.getCurrentFocusInfo();\n}\n...\nmethod: {\n  // 手动查询当前坐标\n  getCurrentFocusInfo() {\n    console.log('当前焦点信息 ===>', controllerCase.getLocationInfo());\n  }\n}\n...\n\n/*\n  控制台输出:  当前焦点信息 ===> { currentX: 3, currentY: 2, lastX: -1, lastY: -1 }\n  由于没有上一个落焦点，所以上一个点坐标都是-1\n*/ \n\n",x='<div id="App">\n\n  \x3c!-- 主内容图层 --\x3e\n  <div id="content">\n    \x3c!-- Tab切换导航 --\x3e\n    <div class="tab-list scoped" scoped="1">\n      <div class="list-item incontroll selected">Tab-item-1</div>\n      <div class="list-item incontroll">Tab-item-2</div>\n      <div class="list-item incontroll">Tab-item-3</div>\n    </div>\n\n    <div class="content-list scoped" scoped="2">\n      \x3c!-- Tab对应的内容 --\x3e\n      <ul>\n        <li v-for="item in pageData[currentTab].dataList" class="list-item incontroll">{{item.name}}</li>\n      </ul>\n    </div>\n\n  </div>\n\n</div>\n',u="...\ndata () {\n  return {\n    currentTab: 0,\n    pageData: [\n      {\n        name: 'Tab-item-1',\n        dataList: [\n          { name:'content-item-1-1' },\n          ...\n        ]\n      },{\n        name: 'Tab-item-2',\n        dataList: [\n          { name:'content-item-2-1' },\n          ...\n        ]\n      },{\n        name: 'Tab-item-3',\n        dataList: [\n          { name:'content-item-3-1' },\n          ...\n        ]\n      }\n    ]\n  }\n},\nmounted() {\n  // 初始化\n  controllerCase.initController({\n    id: 'content',\n    defaultPoint: { y: 1, x: 1 },\n    needScroll: true,\n    scrollDirection: 'vertical'\n  });\n\n  // 默认是第一个Tab被选中\n  controllerCase.setScopeSelectedItem({\n    id: 'content',\n    targetY: 1,\n    targetX: 1,\n  });\n\n\n  // 模拟一下：5秒后触发一次页面Tab切换\n  setTimeout(() => {\n    // 切换到第二个TAB，添加一个css: selected，同时移除之前元素的selected\n    controllerCase.setScopeSelectedItem({\n      id: 'content',\n      targetY: 1,\n      targetX: 2,\n    });\n\n    // 切换显示的内容数据, 更新DOM\n    this.currentTab = 1;\n\n    // DOM更新后，要调用update() 方法来通知更新controllerCase数据\n    this.$nextTick(() => {\n\n      controllerCase.update({\n        id: 'content',\n        needUpdateScoped: 2,\n      });\n\n      // 切换TAB后指定落焦到第三个Item\n      controllerCase.goToFocus({\n        targetY: 2,\n        targetX: 3,\n      });\n\n    });\n  }, 5000);\n}\n\n...\n\n"},9524:function(t,n,i){t.exports=i.p+"img/layer-example1.825266fe.png"},8233:function(t){t.exports=JSON.parse('{"tableConfig":{"suitable":false,"width":[20,15,10,20,10,25],"align":["","","","","",""]},"thead":[{"th":"参数"},{"th":"参数类型"},{"th":"是否必传"},{"th":"含义"},{"th":"默认值"},{"th":"备注"}],"tbody":[[{"txt":"id"},{"txt":"String"},{"txt":"是"},{"txt":"DOM的id"},{"txt":""},{"txt":"标识一个可以落焦的图层，必传","focus":true}],[{"txt":"defaultPoint"},{"txt":"Object"},{"txt":"是"},{"txt":"该图层默认落焦点坐标"},{"txt":""},{"txt":"例：{ y: 1, x: 1 }"}],[{"txt":"defaultPoint.y"},{"txt":"Number"},{"txt":"是"},{"txt":"落焦点所在的scope值"},{"txt":"-1"},{"txt":"<div class=\'list scoped\' scoped=\'1\'></div>"}],[{"txt":"defaultPoint.x"},{"txt":"Number"},{"txt":"是"},{"txt":"落焦点所在scope的第几个位置"},{"txt":"-1"},{"txt":""}],[{"txt":"needScroll"},{"txt":"Boolean"},{"txt":"否"},{"txt":"该图层是否需要滚动"},{"txt":"false"},{"txt":""}],[{"txt":"scrollDirection"},{"txt":"String"},{"txt":"否"},{"txt":"滚动方向: \'horizontal\' / \'vertical\'"},{"txt":""},{"txt":"needScroll=true 时，该字段为必传字段","focus":true}],[{"txt":"scrollBarConfig"},{"txt":"Object"},{"txt":"否"},{"txt":"滚动条配置项"},{"txt":""},{"txt":"用于自定义滚动条样式"}],[{"txt":"scrollBarConfig.showScrollBar"},{"txt":"Boolean"},{"txt":"否"},{"txt":"是否展示滚动条"},{"txt":"false"},{"txt":"false 表示滚动条会隐藏"}],[{"txt":"scrollBarConfig.trackWidth"},{"txt":"String"},{"txt":"否"},{"txt":"滚动条宽度"},{"txt":"8px"},{"txt":""}],[{"txt":"scrollBarConfig.trackBackground"},{"txt":"String"},{"txt":"否"},{"txt":"滚动条背景色"},{"txt":"none"},{"txt":""}],[{"txt":"scrollBarConfig.trackBorderRadius"},{"txt":"String"},{"txt":"否"},{"txt":"滚动条轨道圆角"},{"txt":"0px"},{"txt":""}],[{"txt":"scrollBarConfig.thumbColor"},{"txt":"String"},{"txt":"否"},{"txt":"滚动滑块颜色"},{"txt":"rgba(255,255,255,0)"},{"txt":""}],[{"txt":"scrollBarConfig.thumbBorderWidth"},{"txt":"String"},{"txt":"否"},{"txt":"滚动滑块边框宽度"},{"txt":"0"},{"txt":""}],[{"txt":"scrollBarConfig.thumbBorderColor"},{"txt":"String"},{"txt":"否"},{"txt":"滚动滑块边框颜色"},{"txt":"none"},{"txt":""}],[{"txt":"scrollBarConfig.thumbBorderRadius"},{"txt":"String"},{"txt":"否"},{"txt":"滚动滑块圆角"},{"txt":"4px"},{"txt":""}],[{"txt":"scrollBarConfig.thumbHoverColor"},{"txt":"String"},{"txt":"否"},{"txt":"滚动滑块鼠标悬浮颜色"},{"txt":"rgba(255,255,255,0)"},{"txt":""}],[{"txt":"callBackFn"},{"txt":"Object"},{"txt":"否"},{"txt":"默认回调方法传入"},{"txt":""},{"txt":"默认回调方法的Function Name值是固定的"}],[{"txt":"callBackFn.cbFocusUp"},{"txt":"Function"},{"txt":"否"},{"txt":"按“上”键的默认回调方法"},{"txt":""},{"txt":""}],[{"txt":"callBackFn.cbFocusDown"},{"txt":"Function"},{"txt":"否"},{"txt":"按“下”键的默认回调方法"},{"txt":""},{"txt":""}],[{"txt":"callBackFn.cbFocusLeft"},{"txt":"Function"},{"txt":"否"},{"txt":"按“左”键的默认回调方法"},{"txt":""},{"txt":""}],[{"txt":"callBackFn.cbFocusRight"},{"txt":"Function"},{"txt":"否"},{"txt":"按“右”键的默认回调方法"},{"txt":""},{"txt":""}],[{"txt":"callBackFn.cbBackSpace"},{"txt":"Function"},{"txt":"否"},{"txt":"按“返回/后退”键的默认回调方法"},{"txt":""},{"txt":""}],[{"txt":"callBackFn.cbFocusChange"},{"txt":"Function"},{"txt":"否"},{"txt":"焦点移动默认回调方法"},{"txt":""},{"txt":"焦点每次移动后默认触发，与方向键的回调并不冲突"}],[{"txt":"selfDefinedCallBackFn"},{"txt":"Object"},{"txt":"否"},{"txt":"自定义回调方法存储沙盒对象"},{"txt":""},{"txt":"开发者随意定义的方法名称与方法的映射关系"}],[{"txt":"selfDefinedCallBackFn.XXXXXXX"},{"txt":"Function"},{"txt":"否"},{"txt":"自定义的回调方法传入"},{"txt":""},{"txt":"自定义的回调的Function Name值是开发者自己随意定义的"}]]}')}}]);
//# sourceMappingURL=AddNewControllerPage.b2013b6f.js.map