{"version":3,"file":"js/DataBindPage.3f8bbf43.js","mappings":"kKAAA,IAAIA,EAAS,WAAkB,IAAIC,EAAIC,KAAKC,EAAGF,EAAIG,MAAMD,GAAG,OAAOA,EAAG,MAAM,CAACE,YAAY,2CAA2C,CAACF,EAAG,MAAM,CAACE,YAAY,gBAAgB,CAACJ,EAAIK,GAAG,UAAUL,EAAIM,GAAG,GAAGN,EAAIM,GAAG,GAAGJ,EAAG,MAAM,CAACE,YAAY,0BAA0B,CAACJ,EAAIK,GAAG,UAAUH,EAAG,WAAW,CAACK,MAAM,CAAC,SAAWP,EAAIQ,aAAa,SAAW,UAAUN,EAAG,MAAM,CAACE,YAAY,0BAA0B,CAACJ,EAAIK,GAAG,aAAaH,EAAG,WAAW,CAACK,MAAM,CAAC,SAAWP,EAAIS,OAAO,SAAW,gBAAgBP,EAAG,MAAM,CAACE,YAAY,qBAAqB,CAACJ,EAAIK,GAAG,+CAA+CH,EAAG,cAAc,CAACK,MAAM,CAAC,GAAK,CAAEG,KAAM,cAAc,CAACR,EAAG,OAAO,CAACE,YAAY,gBAAgB,CAACJ,EAAIK,GAAG,UAAUL,EAAIK,GAAG,OAAO,IAAI,EACxsB,EACIM,EAAkB,CAAC,WAAY,IAAIX,EAAIC,KAAKC,EAAGF,EAAIG,MAAMD,GAAG,OAAOA,EAAG,MAAM,CAACE,YAAY,qBAAqB,CAACJ,EAAIK,GAAG,iBAAiBH,EAAG,OAAO,CAACE,YAAY,gBAAgB,CAACJ,EAAIK,GAAG,UAAUL,EAAIK,GAAG,+BAA+BH,EAAG,OAAO,CAACE,YAAY,gBAAgB,CAACJ,EAAIK,GAAG,QAAQL,EAAIK,GAAG,KAAKH,EAAG,OAAO,CAACE,YAAY,gBAAgB,CAACJ,EAAIK,GAAG,QAAQL,EAAIK,GAAG,uBAAuBH,EAAG,OAAO,CAACE,YAAY,gBAAgB,CAACJ,EAAIK,GAAG,qBAAqBL,EAAIK,GAAG,oCAC7c,EAAE,WAAY,IAAIL,EAAIC,KAAKC,EAAGF,EAAIG,MAAMD,GAAG,OAAOA,EAAG,MAAM,CAACE,YAAY,sBAAsB,CAACF,EAAG,MAAM,CAACE,YAAY,WAAW,CAACF,EAAG,OAAO,CAACE,YAAY,gBAAgB,CAACJ,EAAIK,GAAG,eAAeL,EAAIK,GAAG,uCAAuCH,EAAG,OAAO,CAACE,YAAY,gBAAgB,CAACJ,EAAIK,GAAG,YAAYL,EAAIK,GAAG,aAAaH,EAAG,OAAO,CAACE,YAAY,gBAAgB,CAACJ,EAAIK,GAAG,YAAYL,EAAIK,GAAG,sDAC9X,G,mBCqBA,GACAK,KAAA,eACAE,WAAA,CACAC,SAAAA,EAAAA,GAEAC,IAAAA,GACA,OACAC,SAAA,IACAN,OAAAA,EAAAA,EAEA,EACAO,SAAA,CACAR,YAAAA,GACA,YAAAO,QACA,EACAE,UAAAA,GACA,YAAAR,MACA,IC1C2P,I,UCOvPS,GAAY,OACd,EACAnB,EACAY,GACA,EACA,KACA,KACA,MAIF,EAAeO,EAAiB,O,8EClBzB,MAAMH,EAAY,0jBAkBZN,EAAU,g5C","sources":["webpack://layerscoper/./src/pages/DataBindPage.vue","webpack://layerscoper/src/pages/DataBindPage.vue","webpack://layerscoper/./src/pages/DataBindPage.vue?f7ff","webpack://layerscoper/./src/pages/DataBindPage.vue?76f1","webpack://layerscoper/./src/configData/databind/dataBindData.js"],"sourcesContent":["var render = function render(){var _vm=this,_c=_vm._self._c;return _c('div',{staticClass:\"databindpage-content ls-content-wrapper\"},[_c('div',{staticClass:\"ls-title-lv1\"},[_vm._v(\"数据绑定\")]),_vm._m(0),_vm._m(1),_c('div',{staticClass:\"ls-title-lv2 ls-top-30\"},[_vm._v(\"HTML\")]),_c('CodeView',{attrs:{\"codeText\":_vm.dataHtmlCode,\"codeType\":'html'}}),_c('div',{staticClass:\"ls-title-lv2 ls-top-30\"},[_vm._v(\"绑定数据到节点\")]),_c('CodeView',{attrs:{\"codeText\":_vm.dataJs,\"codeType\":'javascript'}}),_c('div',{staticClass:\"ls-text ls-top-30\"},[_vm._v(\" DOM节点绑定数据之后，数据去了那里？怎么回传给开发者？开发者还能知道哪些信息？详见\"),_c('router-link',{attrs:{\"to\":{ name: 'callback'}}},[_c('span',{staticClass:\"ls-textfocus\"},[_vm._v(\"回调\")])]),_vm._v(\"。 \")],1)],1)\n}\nvar staticRenderFns = [function (){var _vm=this,_c=_vm._self._c;return _c('div',{staticClass:\"ls-text ls-top-40\"},[_vm._v(\" Web应用技术发展至今，\"),_c('span',{staticClass:\"ls-textfocus\"},[_vm._v(\"数据绑定\")]),_vm._v(\"以及数据驱动才是渲染的核心。大多数的应用场景下数据会以\"),_c('span',{staticClass:\"ls-textfocus\"},[_vm._v(\"同步\")]),_vm._v(\"或\"),_c('span',{staticClass:\"ls-textfocus\"},[_vm._v(\"异步\")]),_vm._v(\"方式来绑定到DOM节点上，当某个节点的\"),_c('span',{staticClass:\"ls-textfocus\"},[_vm._v(\"事件绑定(EventBind)\")]),_vm._v(\"被触发时，开发者可以根据绑定到该节点的数据来进行后续的操作。 \")])\n},function (){var _vm=this,_c=_vm._self._c;return _c('div',{staticClass:\"ls-block ls-top-20\"},[_c('div',{staticClass:\"ls-text\"},[_c('span',{staticClass:\"ls-textfocus\"},[_vm._v(\"Attribute\")]),_vm._v(\" 只能接收字符串，因此binddata只能传字符串类型的数据，即便传了\"),_c('span',{staticClass:\"ls-textfocus\"},[_vm._v(\"Number\")]),_vm._v(\"，最终也会被转换成\"),_c('span',{staticClass:\"ls-textfocus\"},[_vm._v(\"String\")]),_vm._v(\"。为了保证数据的类型不会在绑定过程中改变，建议使用Object包裹，并转化成JSON来绑定。 \")])])\n}]\n\nexport { render, staticRenderFns }","<template>\r\n  <div class=\"databindpage-content ls-content-wrapper\">\r\n    <div class=\"ls-title-lv1\">数据绑定</div>\r\n    <div class=\"ls-text ls-top-40\">\r\n      Web应用技术发展至今，<span class=\"ls-textfocus\">数据绑定</span>以及数据驱动才是渲染的核心。大多数的应用场景下数据会以<span class=\"ls-textfocus\">同步</span>或<span class=\"ls-textfocus\">异步</span>方式来绑定到DOM节点上，当某个节点的<span class=\"ls-textfocus\">事件绑定(EventBind)</span>被触发时，开发者可以根据绑定到该节点的数据来进行后续的操作。\r\n    </div>\r\n    <div class=\"ls-block ls-top-20\">\r\n      <div class=\"ls-text\">\r\n        <span class=\"ls-textfocus\">Attribute</span> 只能接收字符串，因此binddata只能传字符串类型的数据，即便传了<span class=\"ls-textfocus\">Number</span>，最终也会被转换成<span class=\"ls-textfocus\">String</span>。为了保证数据的类型不会在绑定过程中改变，建议使用Object包裹，并转化成JSON来绑定。\r\n      </div>\r\n    </div>\r\n    <div class=\"ls-title-lv2 ls-top-30\">HTML</div>\r\n    <CodeView :codeText=\"dataHtmlCode\" :codeType=\"'html'\"></CodeView>\r\n    <div class=\"ls-title-lv2 ls-top-30\">绑定数据到节点</div>\r\n    <CodeView :codeText=\"dataJs\" :codeType=\"'javascript'\"></CodeView>\r\n    <div class=\"ls-text ls-top-30\">\r\n      DOM节点绑定数据之后，数据去了那里？怎么回传给开发者？开发者还能知道哪些信息？详见<router-link :to=\"{ name: 'callback'}\"><span class=\"ls-textfocus\">回调</span></router-link>。\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport CodeView from '@/components/CodeView.vue';\r\nimport { dataHtml, dataJs } from '@/configData/databind/dataBindData.js';\r\n\r\nexport default {\r\n  name: 'DataBindPage',\r\n  components: {\r\n    CodeView,\r\n  },\r\n  data() {\r\n    return {\r\n      dataHtml,\r\n      dataJs,\r\n    }\r\n  },\r\n  computed: {\r\n    dataHtmlCode() {\r\n      return this.dataHtml;\r\n    },\r\n    dataJsCode() {\r\n      return this.dataJs;\r\n    },\r\n  },\r\n}\r\n</script>\r\n\r\n<style>\r\n</style>","import mod from \"-!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./DataBindPage.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./DataBindPage.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./DataBindPage.vue?vue&type=template&id=16a1d482\"\nimport script from \"./DataBindPage.vue?vue&type=script&lang=js\"\nexport * from \"./DataBindPage.vue?vue&type=script&lang=js\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","export const dataHtml = `<!--\r\n  Attribute只能接收字符串，因此binddata只能传字符串类型，为了保证数据的类型不会在绑定过程中改变，建议使用Object包裹\r\n-->\r\n<div id=\"content\">\r\n  <div class=\"list scoped\" scoped=\"1\">\r\n    <div class=\"list-item incontroll\" binddata={JSON.stringify(dataObject1)}>落焦点-item-1</div>\r\n    <div class=\"list-item incontroll\" binddata={JSON.stringify(dataObject2)}>落焦点-item-2</div>\r\n  </div>\r\n  <div class=\"list2 scoped\" scoped=\"2\">\r\n    <div\r\n      v-for=\"item in dataList\"\r\n      :key=\"item.id\"\r\n      class=\"list-item incontroll\"\r\n      binddata={JSON.stringify(item)}>{{item.name}}</div>\r\n  </div>\r\n</div>\r\n`;\r\n\r\nexport const dataJs = `import { ScopeController } from 'utils/scopeController';\r\n\r\nconst controllerCase = new ScopeController();\r\n...\r\ndata() {\r\n  return {\r\n    dataObject1: {\r\n      id: 1,\r\n      age: 23,\r\n    },\r\n    dataObject2: {\r\n      id: 2,\r\n      sex: \"male\"\r\n    },\r\n    dataList: [{\r\n      id: 4,\r\n      name: \"Jack\"\r\n    },{\r\n      id: 5,\r\n      name: \"Tom\"\r\n    },{\r\n      id: 6,\r\n      name: \"Michael\"\r\n    }]\r\n  }\r\n}\r\n\r\n// Api: initController() 用于初始化，只需在DOM加载完成后调用一次即可\r\n...\r\nmounted() {\r\n  controllerCase.initController({\r\n    id: 'content',\r\n    defaultPoint: { y: 1, x: 1 },\r\n    callBackFn: {\r\n      cbFocusUp: this.onFocusUpCallback,\r\n      cbFocusDown: this.onFocusDownCallback,\r\n      cbFocusLeft: this.onFocusLeftCallback,\r\n      cbFocusRight: this.onFocusRightCallback,\r\n      cbBackSpace: this.onBackSpaceClickCallback,\r\n      cbFocusChange: this.onFocusChangeCallback,\r\n    }\r\n  });\r\n}\r\n...\r\n\r\n// 回调预留方法，开发者自定义，并传入初始化\r\n...\r\nmethod: {\r\n  // 默认回调绑定的方法\r\n  onFocusUpCallback(cbData) {\r\n    console.log('焦点上移', cbData.);\r\n  },\r\n  onFocusDownCallback(cbData) {\r\n    console.log('焦点下移', cbData);\r\n  },\r\n  onFocusLeftCallback(cbData) {\r\n    console.log('焦点左移', cbData);\r\n  },\r\n  onFocusRightCallback(cbData) {\r\n    console.log('焦点右移', cbData);\r\n  },\r\n  onBackSpaceClickCallback(cbData) {\r\n    console.log('按了后退/返回键', cbData);\r\n  },\r\n  onFocusChangeCallback(cbData) {\r\n    console.log('焦点移动/改变', cbData);\r\n  },\r\n}\r\n...\r\n\r\n`;"],"names":["render","_vm","this","_c","_self","staticClass","_v","_m","attrs","dataHtmlCode","dataJs","name","staticRenderFns","components","CodeView","data","dataHtml","computed","dataJsCode","component"],"sourceRoot":""}