"use strict";(self["webpackChunklayerscoper"]=self["webpackChunklayerscoper"]||[]).push([[425],{6849:function(t,s,n){n.r(s),n.d(s,{default:function(){return u}});var e=function(){var t=this,s=t._self._c;return s("div",{staticClass:"eventpage-content ls-content-wrapper"},[s("div",{staticClass:"ls-title-lv1"},[t._v("事件绑定")]),t._m(0),t._m(1),s("div",{staticClass:"ls-title-lv2 ls-top-30"},[t._v("HTML")]),s("CodeView",{attrs:{codeText:t.eventHtmlCode,codeType:"html"}}),s("div",{staticClass:"ls-title-lv2 ls-top-30"},[t._v("初始化绑定事件")]),s("CodeView",{attrs:{codeText:t.eventJsCode,codeType:"javascript"}}),t._m(2)],1)},l=[function(){var t=this,s=t._self._c;return s("div",{staticClass:"ls-text ls-top-40"},[t._v(" Layer Scoper会根据内置的属性来绑定事件，便于开发者来通过事件去驱动产品功能和逻辑。由于面向的使用场景大都是非触控型设备，事件主要都集中在"),s("span",{staticClass:"ls-textfocus"},[t._v("“上、下、左、右等方向，确认，返回”")]),t._v("这几个按键上。Layer Scoper提供了很灵活的"),s("span",{staticClass:"ls-textfocus"},[t._v("Attribute")]),t._v("绑定自定义方法以及接入方法，代码如下： ")])},function(){var t=this,s=t._self._c;return s("div",{staticClass:"ls-block ls-top-20"},[s("div",{staticClass:"ls-text"},[s("span",{staticClass:"ls-textfocus"},[t._v("Attribute ")]),t._v("作为Html的原生属性，可以绑定一个属性值，但只能接受"),s("span",{staticClass:"ls-textfocus"},[t._v(" String ")]),t._v("类型，不能传入"),s("span",{staticClass:"ls-textfocus"},[t._v("Function")]),t._v('。因此绑定属性的值，其实是一个方法的"命名"，真正的方法是在初始化时根据"命名"值对应来传入到'),s("span",{staticClass:"ls-textfocus"},[t._v("selfDefinedCallBackFn")]),t._v('中，当触发回调时根据"命名"值来找到对应的'),s("span",{staticClass:"ls-textfocus"},[t._v("Function")]),t._v("触发回调。 ")])])},function(){var t=this,s=t._self._c;return s("div",{staticClass:"ls-text ls-top-30"},[t._v(" 要注意的是，当一个DOM节点绑定了一个自定义的方法时，对应同类操作默认的回调就不会再触发了，例如：当"),s("span",{staticClass:"ls-textfocus"},[t._v("goleft")]),t._v("绑定了"),s("span",{staticClass:"ls-textfocus"},[t._v("this.selfGoLeftFn")]),t._v("这个自定义方法时，同样作为“左键”事件的"),s("span",{staticClass:"ls-textfocus"},[t._v("cbFocusLeft: this.onFocusLeftCallback")]),t._v("就不会触发了。自定义方法的优先级是高于默认回调的，也是留给开发者一个完全自主控制的空间。 ")])}],c=n(7795);const o='\x3c!--\n  clickMe selfGoLeft selfGoRight selfGoUp selfGoDown 都是字符串，\n  作为一个Key值，可以在selfDefinedCallBackFn中找到对应的方法\n--\x3e\n<div id="content">\n  <div class="list scoped" scoped="1">\n    <div class="list-item incontroll" clickfocus="clickMe">落焦点-item-1</div>\n    <div class="list-item incontroll" goleft="selfGoLeft" goright="selfGoRight">落焦点-item-2</div>\n    <div class="list-item incontroll" goup="selfGoUp" godown="selfGoDown">落焦点-item-3</div>\n  </div>\n  <div class="list2 scoped" scoped="2">\n    <div class="list2-item incontroll">落焦点-item-1</div>\n    <div class="list2-item">非落焦点-item-2</div>\n    <div class="list2-item">非落焦点-item-3</div>\n    <div class="list2-item incontroll">落焦点-item-4</div>\n  </div>\n</div>\n',a="import LayerScoper from 'layer-scoper';\n\nconst layerScoperCase = new LayerScoper();\n\n// Api: initController() 用于初始化，只需在DOM加载完成后调用一次即可\n...\nmounted() {\n  layerScoperCase.initController({\n    id: 'content',\n    defaultPoint: { y: 1, x: 1 },\n    callBackFn: {\n      cbFocusUp: this.onFocusUpCallback,\n      cbFocusDown: this.onFocusDownCallback,\n      cbFocusLeft: this.onFocusLeftCallback,\n      cbFocusRight: this.onFocusRightCallback,\n      cbBackSpace: this.onBackSpaceClickCallback,\n      cbFocusChange: this.onFocusChangeCallback,\n    },\n    selfDefinedCallBackFn: {\n      clickMe: this.clickMeFn,\n      selfGoLeft: this.selfGoLeftFn,\n      selfGoRight: this.selfGoRightFn,\n      selfGoUp: this.selfGoUpFn,\n      selfGoDown: this.selfGoDownFn,\n    },\n  });\n}\n...\n\n// 回调预留方法，开发者自定义，并传入初始化\n...\nmethod: {\n  // 默认回调绑定的方法\n  onFocusUpCallback(cbData) {\n    console.log('焦点上移', cbData);\n  },\n  onFocusDownCallback(cbData) {\n    console.log('焦点下移', cbData);\n  },\n  onFocusLeftCallback(cbData) {\n    console.log('焦点左移', cbData);\n  },\n  onFocusRightCallback(cbData) {\n    console.log('焦点右移', cbData);\n  },\n  onBackSpaceClickCallback(cbData) {\n    console.log('按了后退/返回键', cbData);\n  },\n  onFocusChangeCallback(cbData) {\n    console.log('焦点移动/改变', cbData);\n  },\n  // 自定义回调绑定的方法\n  clickMeFn(cbData) {\n    console.log('在这个Item点击了确认', cbData);\n  },\n  selfGoLeftFn(cbData) {\n    console.log('在这个Item点击了左键', cbData);\n  },\n  selfGoRightFn(cbData) {\n    console.log('在这个Item点击了右键', cbData);\n  },\n  selfGoUpFn(cbData) {\n    console.log('在这个Item点击了上键', cbData);\n  },\n  selfGoDownFn(cbData) {\n    console.log('在这个Item点击了下键', cbData);\n  },\n}\n...\n\n";var i={name:"EventBindPage",components:{CodeView:c.A},data(){return{eventHtml:o,eventJs:a}},computed:{eventHtmlCode(){return this.eventHtml},eventJsCode(){return this.eventJs}}},v=i,f=n(1656),r=(0,f.A)(v,e,l,!1,null,null,null),u=r.exports}}]);
//# sourceMappingURL=EventBindPage.a5c266e9.js.map